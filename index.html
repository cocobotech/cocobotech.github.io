<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COCOBO</title>
  <!-- 引入 opentype.js 用于文字描边路径计算 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Rajdhani:wght@600&family=Noto+Serif+SC:wght@700;900&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      background: #000000;
      font-family: 'Orbitron', sans-serif;
      height: 100vh;
      display: block; 
      position: relative;
    }

    /* --- 彩虹描边动画容器 --- */
    #tracer-container {
      position: absolute;
      top: 5%;           /* 距离顶部 10% */
      left: 50%;
      transform: translateX(-50%); /* 水平居中 */
      
      width: 90%;
      max-width: 700px;
      height: 200px;
      
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      
      background: rgba(0, 0, 0, 0.4); 
      backdrop-filter: blur(4px);
      border-radius: 20px;
      
      /* 初始边框 */
      border: 2px solid rgba(255, 255, 255, 0.3);

      /* 边框火焰/流光动画 */
      animation: fireBorder 4s linear infinite;
    }

    @keyframes fireBorder {
      0% {
        border-color: #ff0000;
        box-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000, inset 0 0 10px #ff0000;
      }
      20% {
        border-color: #ffcc00;
        box-shadow: 0 0 15px #ffcc00, 0 0 30px #ffcc00, inset 0 0 10px #ffcc00;
      }
      40% {
        border-color: #00ff00;
        box-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00, inset 0 0 10px #00ff00;
      }
      60% {
        border-color: #00ccff;
        box-shadow: 0 0 15px #00ccff, 0 0 30px #00ccff, inset 0 0 10px #00ccff;
      }
      80% {
        border-color: #cc00ff;
        box-shadow: 0 0 15px #cc00ff, 0 0 30px #cc00ff, inset 0 0 10px #cc00ff;
      }
      100% {
        border-color: #ff0000;
        box-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000, inset 0 0 10px #ff0000;
      }
    }

    svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    /* 全局色相旋转动画 */
    .rainbow-animate {
      animation: hueRotate 6s linear infinite;
    }

    @keyframes hueRotate {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    /* 1. 底部暗色轨迹 */
    .path-bg {
      fill: none;
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* 2. 高亮描边 (使用渐变) */
    .path-trace {
      fill: none;
      stroke: url(#rainbow-gradient);
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.8)) 
              drop-shadow(0 0 15px currentColor)
              drop-shadow(0 0 30px currentColor);
      opacity: 0.95;
    }

    /* 3. 倒影样式 */
    .reflection {
      opacity: 0.3;
      filter: blur(4px);
      pointer-events: none;
    }

    /* 4. 光晕粒子 */
    .halo-group {
      mix-blend-mode: screen;
    }
    .halo-glow {
      fill: url(#rainbow-gradient);
      filter: blur(6px);
      opacity: 0.8;
    }
    .halo-core {
      fill: #fff;
      filter: drop-shadow(0 0 5px #fff);
    }

    /* --- 底部按钮样式 --- */
    button.enter-btn {
      position: absolute;
      bottom: 15%; 
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 30px;
      font-family: 'Rajdhani', sans-serif;
      font-size: 1.4rem;
      font-weight: bold;
      background: linear-gradient(45deg, #ff006e, #3a86ff);
      border: none;
      border-radius: 50px;
      color: white;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(255,0,110,0.4);
      transition: all 0.3s;
      z-index: 20;
      letter-spacing: 2px;
    }
    button.enter-btn:hover {
      transform: translateX(-50%) translateY(-5px);
      box-shadow: 0 20px 40px rgba(131,56,236,0.8);
    }

    /* 背景 Canvas */
    canvas {
      position: fixed;
      top: 0; left: 0;
      z-index: -1;
    }
  </style>
</head>
<body>

  <!-- 彩虹描边文字区域 -->
  <div id="tracer-container">
      <svg id="svg-stage" viewBox="0 0 1000 380" preserveAspectRatio="xMidYMid meet">
          <defs>
              <linearGradient id="rainbow-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                  <stop offset="0%" stop-color="#ff0000" />
                  <stop offset="20%" stop-color="#ffbe00" />
                  <stop offset="40%" stop-color="#00ff00" />
                  <stop offset="60%" stop-color="#0099ff" />
                  <stop offset="80%" stop-color="#9900ff" />
                  <stop offset="100%" stop-color="#ff0080" />
              </linearGradient>
              <linearGradient id="fade-gradient" x1="0" x2="0" y1="0" y2="1">
                  <stop offset="0%" stop-color="white" stop-opacity="0.4"/>
                  <stop offset="100%" stop-color="white" stop-opacity="0"/>
              </linearGradient>
              <mask id="reflection-mask">
                  <rect x="0" y="0" width="100%" height="100%" fill="url(#fade-gradient)" />
              </mask>
          </defs>
      </svg>
  </div>

  <button class="enter-btn" onclick="window.location='https://cocobotech.github.io/home.html'">ENTER</button>

  <canvas id="bg_animation_wave1"></canvas>

  <script>
    // ==========================================
    // PART 1: 文字描边动画 (Rainbow Tracer)
    // ==========================================
    function initTracerAnimation() {
        let font = null;
        const svgStage = document.getElementById('svg-stage');
        const targetText = "COCOBO"; 

        const fontUrl = 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/pacifico/Pacifico-Regular.ttf';

        opentype.load(fontUrl, function(err, loadedFont) {
            if (err) {
                console.error('Font loading error:', err);
            } else {
                font = loadedFont;
                startTracer(font, targetText, svgStage);
            }
        });
    }

    function startTracer(font, text, svgStage) {
        const oldGroups = svgStage.querySelectorAll('g');
        oldGroups.forEach(g => g.remove());

        const pathObject = font.getPath(text, 0, 0, 180); 
        const pathData = pathObject.toPathData(2);

        const mainGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        mainGroup.setAttribute("class", "rainbow-animate");
        svgStage.appendChild(mainGroup);

        const contentGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const reflectionGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        reflectionGroup.setAttribute("class", "reflection");
        reflectionGroup.setAttribute("mask", "url(#reflection-mask)");

        mainGroup.appendChild(reflectionGroup);
        mainGroup.appendChild(contentGroup);

        const createPath = (d, cls) => {
            const el = document.createElementNS("http://www.w3.org/2000/svg", "path");
            el.setAttribute("d", d);
            el.setAttribute("class", cls);
            return el;
        };

        const bgPath = createPath(pathData, "path-bg");
        contentGroup.appendChild(bgPath);
        reflectionGroup.appendChild(bgPath.cloneNode(true));

        const tracePath = createPath(pathData, "path-trace");
        contentGroup.appendChild(tracePath);
        const reflectTrace = tracePath.cloneNode(true);
        reflectionGroup.appendChild(reflectTrace);

        const haloGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        haloGroup.setAttribute("class", "halo-group");
        
        const haloGlow = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        haloGlow.setAttribute("r", "14");
        haloGlow.setAttribute("class", "halo-glow");
        
        const haloCore = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        haloCore.setAttribute("r", "5");
        haloCore.setAttribute("class", "halo-core");

        haloGroup.appendChild(haloGlow);
        haloGroup.appendChild(haloCore);
        contentGroup.appendChild(haloGroup);

        const bbox = bgPath.getBBox();
        const svgWidth = 1000;
        const svgHeight = 400;
        const xOffset = (svgWidth - bbox.width) / 2 - bbox.x;
        const yOffset = (svgHeight - bbox.height) / 2 - bbox.y - 20;

        contentGroup.setAttribute("transform", `translate(${xOffset}, ${yOffset})`);
        reflectionGroup.setAttribute("transform", 
            `translate(${xOffset}, ${yOffset}) translate(0, ${bbox.y + bbox.height * 2 + 25}) scale(1, -1)`
        );

        const totalLength = tracePath.getTotalLength();
        tracePath.style.strokeDasharray = `${totalLength} ${totalLength}`;
        reflectTrace.style.strokeDasharray = `${totalLength} ${totalLength}`;
        
        let startTime = null;
        const duration = 5000; // 动画时长 5 秒

        function step(timestamp) {
            if (!startTime) startTime = timestamp;
            const rawProgress = (timestamp - startTime) / duration;
            
            // 确保进度最大为 1
            const progress = Math.min(rawProgress, 1);

            const ease = 1 - Math.pow(1 - progress, 3); 

            const currentOffset = totalLength * (1 - ease);
            const currentLength = totalLength * ease;

            tracePath.style.strokeDashoffset = currentOffset;
            reflectTrace.style.strokeDashoffset = currentOffset;

            const p = tracePath.getPointAtLength(currentLength);
            haloGroup.setAttribute("transform", `translate(${p.x}, ${p.y})`);

            let opacity = 1;
            if (progress < 0.02) opacity = progress * 50;
            if (progress >= 1) opacity = 0; // 结束后隐藏光球
            haloGroup.style.opacity = opacity;

            if (rawProgress < 1) {
                requestAnimationFrame(step);
            } else {
                // --- 循环逻辑：等待2秒后重启 ---
                setTimeout(() => {
                    startTime = null; // 重置时间，让动画从头开始
                    requestAnimationFrame(step);
                }, 2000); // 2000 毫秒 = 2 秒
            }
        }
        requestAnimationFrame(step);
    }


    // ==========================================
    // PART 2: 背景波浪动画
    // ==========================================
    function startBackgroundAnimation(canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      let time = 0;
      let lines = [];

      const numLines = 6;
      const lineHeight = 38;
      const amplitude = 110;
      const frequency = 0.012;
      const speed = 0.01;
      const hueShiftSpeed = 2;

      const fixedNumbers = [];
      const meteors = [];

      class Meteor {
        constructor() { this.reset(); }
        reset() {
          this.x = canvas.width + Math.random() * 200;
          this.y = -50 - Math.random() * 100;
          this.speedX = -(3 + Math.random() * 4);
          this.speedY = 2 + Math.random() * 3;
          this.length = 80 + Math.random() * 120;
          this.thickness = 1.5 + Math.random() * 2;
          this.hue = Math.random() * 360;
          this.alpha = 0.8 + Math.random() * 0.2;
          this.trail = [];
          this.maxTrail = 15;
        }
        update() {
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.maxTrail) this.trail.shift();
          this.x += this.speedX;
          this.y += this.speedY;
          if (this.x < -this.length || this.y > canvas.height + 100) this.reset();
        }
        draw() {
          for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const trailAlpha = (i / this.trail.length) * this.alpha * 0.5;
            ctx.beginPath();
            ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, ${trailAlpha})`;
            ctx.lineWidth = this.thickness * (i / this.trail.length);
            if (i > 0) {
              const prev = this.trail[i - 1];
              ctx.moveTo(prev.x, prev.y);
              ctx.lineTo(point.x, point.y);
            }
            ctx.stroke();
          }
          const gradient = ctx.createLinearGradient(
            this.x, this.y, this.x + this.speedX * 10, this.y + this.speedY * 10
          );
          gradient.addColorStop(0, `hsla(${this.hue}, 100%, 90%, ${this.alpha})`);
          gradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 70%, ${this.alpha * 0.6})`);
          gradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0)`);
          ctx.save();
          ctx.shadowBlur = 25;
          ctx.shadowColor = `hsl(${this.hue}, 100%, 70%)`;
          ctx.strokeStyle = gradient;
          ctx.lineWidth = this.thickness;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x + this.speedX * 10, this.y + this.speedY * 10);
          ctx.stroke();
          ctx.restore();
        }
      }

      class FixedNumber {
        constructor(char, lineIndex, positionRatio, english) {
          this.char = char;
          this.english = english;
          this.lineIndex = lineIndex;
          this.positionRatio = positionRatio;
          this.size = 36;
          this.englishSize = 16;
        }
        draw(currentTime) {
          if (this.lineIndex >= lines.length) return;
          const line = lines[this.lineIndex];
          const x = this.positionRatio * canvas.width;
          const y = getWaveY(line, x, currentTime);
          const hue = (line.colorHue + currentTime * hueShiftSpeed + this.lineIndex * 40) % 360;
          const alpha = 0.92 + Math.sin(currentTime * 2 + this.lineIndex) * 0.08;
          const glow = 35 + Math.sin(currentTime * 3 + this.lineIndex * 0.5) * 15;
          ctx.save();
          ctx.shadowBlur = glow;
          ctx.shadowColor = `hsl(${hue}, 100%, 65%)`;
          ctx.font = `900 ${this.size}px 'Noto Serif SC', serif`;
          ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${alpha})`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeStyle = `hsla(${hue}, 100%, 90%, ${alpha * 0.6})`;
          ctx.lineWidth = 2;
          ctx.strokeText(this.char, x, y);
          ctx.fillText(this.char, x, y);
          ctx.shadowBlur = 0;
          ctx.font = `600 ${this.englishSize}px 'Rajdhani', sans-serif`;
          ctx.fillStyle = `rgba(160, 160, 160, 0.85)`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(this.english, x, y + 22);
          ctx.restore();
        }
      }

      function initFixedNumbers() {
        fixedNumbers.length = 0;
        const spacing = 1 / 4;
        fixedNumbers.push(new FixedNumber('仁爱', 0, spacing * 0.6, 'Love'));
        fixedNumbers.push(new FixedNumber('喜乐', 0, spacing * 1.6, 'Joy'));
        fixedNumbers.push(new FixedNumber('和平', 0, spacing * 2.6, 'Peace'));
        fixedNumbers.push(new FixedNumber('忍耐', 2, spacing * 1.2, 'Patience'));
        fixedNumbers.push(new FixedNumber('恩慈', 2, spacing * 2.2, 'Kindness'));
        fixedNumbers.push(new FixedNumber('良善', 2, spacing * 3.2, 'Goodness'));
        fixedNumbers.push(new FixedNumber('信实', 4, spacing * 0.8, 'Faithfulness'));
        fixedNumbers.push(new FixedNumber('温柔', 4, spacing * 1.8, 'Gentleness'));
        fixedNumbers.push(new FixedNumber('节制', 4, spacing * 2.8, 'Self-Control'));
      }

      function initMeteors() {
        meteors.length = 0;
        const meteorCount = 8;
        for (let i = 0; i < meteorCount; i++) {
          const meteor = new Meteor();
          meteor.x = Math.random() * canvas.width;
          meteor.y = -Math.random() * canvas.height * 0.5;
          meteors.push(meteor);
        }
      }

      function initLines() {
        lines = [];
        const startY = (canvas.height - (numLines * lineHeight * 2)) / 2 + 50;
        for (let i = 0; i < numLines; i++) {
          lines.push({
            startY: startY + i * lineHeight * 2,
            colorHue: i * 60,
            offset: i * 1.2
          });
        }
      }

      function getWaveY(line, x, t) {
        return line.startY +
          Math.sin(x * frequency + t * 1.5 + line.offset) * amplitude * 0.6 +
          Math.sin(x * frequency * 0.7 - t * 0.9 + line.offset * 2) * amplitude * 0.4;
      }

      function animate() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.97)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        time += speed;
        lines.forEach((line, i) => {
          ctx.beginPath();
          const hue = (line.colorHue + time * hueShiftSpeed) % 360;
          const thickness = 4 + Math.sin(time * 2 + i) * 3;
          ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.85)`;
          ctx.lineWidth = thickness;
          ctx.shadowBlur = 22;
          ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
          for (let x = 0; x <= canvas.width; x += 2) {
            const y = getWaveY(line, x, time);
            x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.stroke();
        });
        meteors.forEach(meteor => { meteor.update(); meteor.draw(); });
        fixedNumbers.forEach(n => n.draw(time));
        requestAnimationFrame(animate);
      }

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        initLines();
        initFixedNumbers();
        initMeteors();
      }

      resize();
      window.addEventListener('resize', resize);
      animate();
    }

    window.onload = () => {
        startBackgroundAnimation('bg_animation_wave1');
        initTracerAnimation(); 
    };
  </script>
</body>
</html>
