<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mathematical Surface</title>
    <style>
        
        
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0ff;
        }

        .ui-overlay h1 {
            font-size: 20px;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .ui-overlay .formula {
            font-size: 16px;
            margin: 10px 0;
            color: #fff;
            background: rgba(0, 255, 255, 0.1);
            padding: 8px;
            border-radius: 5px;
        }

        .ui-overlay p {
            margin: 5px 0;
            font-size: 12px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0ff;
            color: #0ff;
            font-size: 12px;
            z-index: 100;
        }

        .controls button {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .controls button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px #0ff;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 255, 0.03) 0px,
                rgba(0, 255, 255, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="scanlines"></div>
    
    <div class="ui-overlay">
        <h1>ğŸ“ æ•°å­¦æ›²é¢å¯è§†åŒ–</h1>
        <div class="formula">z = e<sup>-rÂ²/4</sup>(2sin(Ï€r) - rÂ·cos(3Î¸))</div>
        <p>ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | æ»šè½®ç¼©æ”¾</p>
    </div>

    <div class="controls">
        <div style="margin-bottom: 10px;">ğŸ¨ æ˜¾ç¤ºæ¨¡å¼ï¼š</div>
        <button onclick="changeColorMode('rainbow')">å½©è™¹è‰²</button>
        <button onclick="changeColorMode('cyan')">é’è‰²</button>
        <button onclick="changeColorMode('magenta')">æ´‹çº¢</button>
        <button onclick="changeColorMode('height')">é«˜åº¦æ˜ å°„</button>
        <div style="margin-top: 10px;">
            <button onclick="toggleWireframe()">çº¿æ¡†æ¨¡å¼</button>
            <button onclick="toggleRotation()">è‡ªåŠ¨æ—‹è½¬</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let surface, surfaceMesh;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = true;
        let wireframeMode = false;

        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 20, 50);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // å…‰æº
            setupLights();

            // åˆ›å»ºç½‘æ ¼åœ°é¢
            createGrid();

            // åˆ›å»ºæ•°å­¦æ›²é¢
            createMathSurface();

            // äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // å¼€å§‹åŠ¨ç”»
            animate();
        }

        function setupLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // ç‚¹å…‰æºï¼ˆéœ“è™¹æ•ˆæœï¼‰
            const pointLight1 = new THREE.PointLight(0x00ffff, 1.5, 30);
            pointLight1.position.set(0, 10, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff00ff, 1, 25);
            pointLight2.position.set(-10, 5, -10);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xff0080, 1, 25);
            pointLight3.position.set(10, 5, 10);
            scene.add(pointLight3);
        }

        function createGrid() {
            // ç½‘æ ¼åœ°é¢
            const gridSize = 50;
            const gridDivisions = 50;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x00ffff, 0x004444);
            gridHelper.material.opacity = 0.4;
            gridHelper.material.transparent = true;
            gridHelper.position.y = -5;
            scene.add(gridHelper);

            // é¢å¤–çš„äº¤å‰ç½‘æ ¼
            const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions, 0xff00ff, 0x440044);
            gridHelper2.material.opacity = 0.2;
            gridHelper2.material.transparent = true;
            gridHelper2.rotation.y = Math.PI / 4;
            gridHelper2.position.y = -5;
            scene.add(gridHelper2);
        }

        function createMathSurface() {
            // æ•°å­¦å‡½æ•°: z = e^(-rÂ²/4) * (2*sin(Ï€*r) - r*cos(3*Î¸))
            const resolution = 100;
            const size = 10;
            const geometry = new THREE.BufferGeometry();
            
            const vertices = [];
            const colors = [];
            const indices = [];

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const u = (i / resolution) * 2 - 1;
                    const v = (j / resolution) * 2 - 1;
                    
                    // è½¬æ¢ä¸ºæåæ ‡
                    const x = u * size;
                    const y = v * size;
                    const r = Math.sqrt(x * x + y * y);
                    const theta = Math.atan2(y, x);
                    
                    // æ•°å­¦å‡½æ•°
                    const z = Math.exp(-r * r / 4) * (2 * Math.sin(Math.PI * r) - r * Math.cos(3 * theta));
                    
                    vertices.push(x, z * 3, y); // æ”¾å¤§zå€¼ä»¥ä¾¿è§‚å¯Ÿ
                    
                    // æ ¹æ®é«˜åº¦è®¾ç½®é¢œè‰²ï¼ˆå½©è™¹è‰²ï¼‰
                    const normalizedZ = (z + 1) / 2;
                    const hue = normalizedZ * 0.7; // 0-0.7 å¯¹åº”è“åˆ°çº¢
                    const color = new THREE.Color();
                    color.setHSL(hue, 1, 0.5);
                    colors.push(color.r, color.g, color.b);
                }
            }

            // åˆ›å»ºä¸‰è§’å½¢ç´¢å¼•
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const a = i * (resolution + 1) + j;
                    const b = a + resolution + 1;
                    const c = a + 1;
                    const d = b + 1;

                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            // æè´¨
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                metalness: 0.3,
                roughness: 0.4,
                emissive: 0x002244,
                emissiveIntensity: 0.2
            });

            surfaceMesh = new THREE.Mesh(geometry, material);
            scene.add(surfaceMesh);

            // æ·»åŠ çº¿æ¡†
            const wireframeGeometry = new THREE.WireframeGeometry(geometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });
            const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            surfaceMesh.add(wireframe);
            wireframe.visible = false;
            surfaceMesh.userData.wireframe = wireframe;
        }

        function changeColorMode(mode) {
            const positions = surfaceMesh.geometry.attributes.position.array;
            const colors = surfaceMesh.geometry.attributes.color.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const z = positions[i + 1];
                const normalizedZ = (z / 3 + 1) / 2;
                const color = new THREE.Color();
                
                switch(mode) {
                    case 'rainbow':
                        color.setHSL(normalizedZ * 0.7, 1, 0.5);
                        break;
                    case 'cyan':
                        color.setHSL(0.5, normalizedZ, 0.5);
                        break;
                    case 'magenta':
                        color.setHSL(0.83, 1, normalizedZ * 0.5 + 0.25);
                        break;
                    case 'height':
                        const intensity = normalizedZ;
                        color.setRGB(intensity, intensity * 0.5, intensity);
                        break;
                }
                
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            surfaceMesh.geometry.attributes.color.needsUpdate = true;
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            if (surfaceMesh.userData.wireframe) {
                surfaceMesh.userData.wireframe.visible = wireframeMode;
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
        }

        function setupEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                // æ—‹è½¬ç›¸æœº
                const rotationSpeed = 0.005;
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -deltaX * rotationSpeed);
                
                // ä¸Šä¸‹ç§»åŠ¨
                const currentRadius = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                camera.position.y += deltaY * 0.05;
                camera.position.y = Math.max(1, Math.min(30, camera.position.y));
                
                camera.lookAt(0, 0, 0);
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseWheel(event) {
            const zoomSpeed = 0.1;
            const distance = camera.position.length();
            const newDistance = Math.max(8, Math.min(40, distance + event.deltaY * zoomSpeed * 0.01));
            camera.position.multiplyScalar(newDistance / distance);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0005;

            // è‡ªåŠ¨æ—‹è½¬
            if (autoRotate && !isDragging) {
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.003);
                camera.lookAt(0, 0, 0);
            }

            // æ›²é¢åŠ¨ç”»ï¼ˆè½»å¾®æ³¢åŠ¨ï¼‰
            if (surfaceMesh) {
                surfaceMesh.rotation.y += 0.001;
                
                // å‘å…‰æ•ˆæœè„‰åŠ¨
                surfaceMesh.material.emissiveIntensity = 0.1 + Math.sin(time * 2) * 0.1;
            }

            renderer.render(scene, camera);
        }

        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>
