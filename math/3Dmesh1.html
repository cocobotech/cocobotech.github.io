<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COCOBO 3D Math Mesh1 Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        
        /* 顶部UI */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        p {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            transition: opacity 0.5s;
        }
    </style>
    
    <!-- 引入 Three.js 及其依赖 (使用 ESM 模块) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
      <!-- 
    <div id="ui">
        <h1>Math Surface // <span style="color:#00ffff">Manifold</span></h1>
        <p>f(x,y,t) = sin(ax) * cos(by+t)</p>
    </div>  -->
    <div id="loading">Loading Geometry...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. 场景初始化 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.03); // 黑色雾气增加深空感

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // 电影级色调映射
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // 交互控制
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. 创建数学 Mesh ---
        
        // 我们创建一个高密度的二十面体作为基础，然后用数学公式在每一帧扭曲它
        const geometry = new THREE.IcosahedronGeometry(3, 60); // 高细分用于平滑变形
        
        // 材质：物理材质，模拟磨砂玻璃/半金属
        const material = new THREE.MeshPhysicalMaterial({
            color: 0x111111,       // 基础色
            emissive: 0x000000,
            roughness: 0.2,        // 粗糙度
            metalness: 0.9,        // 金属度
            reflectivity: 1,
            clearcoat: 1.0,        // 清漆层
            clearcoatRoughness: 0.1,
            flatShading: false,
            side: THREE.DoubleSide,
            wireframe: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // 添加一个线框层，增加科技感
        const wireframeMat = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.05,
            wireframe: true,
            blending: THREE.AdditiveBlending
        });
        const wireMesh = new THREE.Mesh(geometry, wireframeMat);
        mesh.add(wireMesh); // 作为子对象绑定

        // 存储原始顶点位置用于计算
        const positionAttribute = geometry.attributes.position;
        const originalPositions = positionAttribute.array.slice();

        // --- 3. 高级打光系统 ---

        // 环境光 (微弱)
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        // 动态光源组 (会让它们旋转)
        const lightsGroup = new THREE.Group();
        scene.add(lightsGroup);

        // 1. 青色光源 (Cyber Blue)
        const light1 = new THREE.PointLight(0x00ffff, 200, 50);
        light1.position.set(5, 5, 5);
        lightsGroup.add(light1);

        // 2. 洋红光源 (Cyber Pink)
        const light2 = new THREE.PointLight(0xff00ff, 200, 50);
        light2.position.set(-5, -5, 5);
        lightsGroup.add(light2);

        // 3. 金色轮廓光 (Gold Rim) - 放在背面
        const light3 = new THREE.PointLight(0xffaa00, 150, 50);
        light3.position.set(0, 5, -8);
        lightsGroup.add(light3);

        // 添加光源辅助球体 (可视化的发光点)
        const sphereGeo = new THREE.SphereGeometry(0.1, 16, 16);
        const lightMesh1 = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({color:0x00ffff}));
        const lightMesh2 = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({color:0xff00ff}));
        light1.add(lightMesh1);
        light2.add(lightMesh2);


        // --- 4. 后处理特效 (Bloom/辉光) ---
        const renderScene = new RenderPass(scene, camera);
        
        // Bloom 参数: resolution, strength, radius, threshold
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 0.8;  // 辉光强度
        bloomPass.radius = 0.5;    // 扩散半径
        bloomPass.threshold = 0.2; // 亮度阈值

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 5. 动画循环与数学计算 ---
        
        let time = 0;
        const loadingEl = document.getElementById('loading');
        if(loadingEl) loadingEl.style.display = 'none';

        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.015; // 时间流速

            // 1. 动态光源旋转
            lightsGroup.rotation.y = time * 0.5;
            lightsGroup.rotation.z = time * 0.2;

            // 2. 核心数学计算：顶点置换 (Vertex Displacement)
            // 我们遍历每一个顶点，根据它的原始位置计算新的位置
            // 使用球谐函数与波的叠加
            
            for (let i = 0; i < positionAttribute.count; i++) {
                // 获取原始坐标
                const ox = originalPositions[i * 3];
                const oy = originalPositions[i * 3 + 1];
                const oz = originalPositions[i * 3 + 2];

                // 转换为球坐标系 (大致) 来计算干扰
                // 使用简单的 3D 噪声模拟算法
                // 距离中心点的距离
                const len = Math.sqrt(ox*ox + oy*oy + oz*oz);
                
                // 数学公式：叠加多个正弦波
                // Wave 1: 沿 X 轴波动
                const wave1 = Math.sin(oy * 2.0 + time) * 0.5;
                // Wave 2: 沿 Y 轴的快速高频波动
                const wave2 = Math.cos(ox * 1.5 + time * 1.5) * 0.3;
                // Wave 3: 整体的呼吸效果
                const breathe = Math.sin(time * 0.5) * 0.2;
                
                // 复杂的干扰因子 (K factor)
                const k = 1 + (wave1 + wave2 + breathe) * 0.4;

                // 应用新的位置
                positionAttribute.setXYZ(
                    i, 
                    ox * k, 
                    oy * k, 
                    oz * k
                );
            }

            // 标记几何体需要更新
            positionAttribute.needsUpdate = true;
            geometry.computeVertexNormals(); // 重新计算法线以保证光照正确

            // 3. 整体旋转
            mesh.rotation.x = time * 0.1;
            mesh.rotation.y = time * 0.05;

            controls.update();
            
            // 使用 composer 渲染以获得辉光效果，而不是 renderer.render
            composer.render();
        }

        // 窗口大小自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
